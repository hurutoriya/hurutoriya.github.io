<!doctype html><html><head><meta name=generator content="Hugo 0.67.1"><script data-ad-client=ca-pub-8604812913439531 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>hurutoriya | Home</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:image" content><link rel=alternate type=application/rss+xml href=https://shunyaueta.com/index.xml title=hurutoriya><meta property="og:title" content="hurutoriya"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://shunyaueta.com/"><meta property="og:updated_time" content="2019-06-15T19:25:33+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="hurutoriya"><meta name=twitter:description content><script src=https://shunyaueta.com/js/feather.min.js></script><link href=https://shunyaueta.com/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://shunyaueta.com/css/main.css><link rel=stylesheet type=text/css href=https://shunyaueta.com/css/dark.css media="(prefers-color-scheme: dark)"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-39994406-11"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-39994406-11');</script></head><body><div class=content><header><div class=main><a href=https://shunyaueta.com/>hurutoriya</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main class=list><div class=site-description></div><section class=list-item><h1 class=title><a href=/posts/2020-09-19/>GitHub codeowners でGithubグループを指定しても反映されない時の対処方法</a></h1><time>Sep 19, 2020</time><br><div class=description>GitHub の CODEOWNERS という機能を使えば、レポジトリに対するPRでは設定された CODEOWNER がAPPROVEを出さないとマージされないようにできます。
この機能を使うことで、例えばそのリポジトリのオーナーであるグループが必ずPRを確認しないとマージできないようにすることでコードのクオリティを保つ仕組みが作れます。
TL;DR GitHub codeowners で特定のグループをCODEOWNERSに設定したいときは、そのグループをレポジトリの /settings/accessで Maintain として追加しないとGitHub PR で自動的にreviwer に追加されない リポジトリで.github/CODEOWNERS のファイルを作成して、以下の形式でGitHub group を追加する * @octo-org/codeowners-team リポジトリの設定の/settings/accessにアクセスして、@octo-org/codeowners-team を Maintain として追加する。 *試していないのですが、Write や Triage 権限でも問題ないかもしれません。
この設定をしたあとに、GitHub PRを新たに作成すると、自動的に CODEOWNERS のapproveがないとマージされないように設定されるはずです。
自分自身がハマった経緯 グループ全体のアカウントが追加されているa-group/allというGithub Groupがすでにリポジトリのアクセス権限に Write 権限として追加されており、全員がwrite権限をもっているならcodeownersとしての権限も問題ないだろうと思っていたらハマりました。
CODEOWNERS の仕組みを知ると理解できるのですが、a-group/all が指定したいグループの包含関係にあるからといって、そのように取り扱ってくれるわけではないということですね。&mldr;</div><a href=/posts/2020-09-19/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-09-09/>pandas を使って特定のディレクトリのCSVファイルをすべて連結して一つのCSVファイルを作成</a></h1><time>Sep 9, 2020</time><br><div class=description>目的 複数の同じフォーマットのCSVファイルが特定のディレクトリに配置されており、そのCSVファイル群を一つのCSVファイルに連結したい
今回は、PythonのPandas とpathlibを使って上記の目的を実現します。
実行環境 In [1]: import pandas as pd In [2]: pd.__version__ Out[2]: '1.1.2 In [3]: import sys ...: print(sys.version) 3.8.2 (default, Jul 19 2020, 07:23:27) [Clang 11.0.3 (clang-1103.0.32.62)] 目的となるcsvファイルは tmp ディレクトリに以下のような形式で配置されているとする
tmp ├── 1.csv ├── 2.csv └── 3.csv 各ファイルはこのような形式で保存されています。
id name created 1 John 2020/09/10 2 bob 2020/09/10 3 taro 2020/09/11 以下のPythonスクリプトを実行
import pathlib import pandas as pd def contcat_csv(f_path:str): # pathlibのitedir()で対象とするディレクトリのCSVファイル一覧をジェネレーターとして取得 csvs = [pd.read_csv(str(path)) for path in pathlib.&mldr;</div><a href=/posts/2020-09-09/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-09-06/>MLOps の国際会議 OpML'20 に論文が採択されたので登壇してきた</a></h1><time>Sep 6, 2020</time><br><div class=description>MLOpsの査読付き国際会議 2020 USENIX Conference on Operational Machine Learning (略称 OpML&rsquo;20)に論文が採択されたので、登壇してきた。
Podcastでも紹介しました
#1 MLOps の国際会議 OpML20 について at just4fun.fm
MLOpsの査読付き国際会議とOpMLの立ち位置 機械学習エンジニアリング・MLOpsの領域の会議でも一番有名なものとして2018年に発足したMLSysがあります。(ちなみに最初はSysMLという名前でした) このカンファレンスの傾向としては、アカデミアの研究者主体の発足経緯からアカデミアからインダストリーへの橋渡し的立ち位置となっています。具体的には、発表者はアカデミアの方が大半でハードウェアから、モデルのOSS公開など幅広く機械学習エンジニアリング・MLOpsの周辺トピックをカバーしています。
OpMLはその一年後に、MLOpsを軸にしたUSENIXが母体の会議として誕生しました。 USENIXはSRECON、OSDIなどを開催している団体です。学会的なスタイルに則り、先端的な計算機システムの成果を論文として公開されています。MLSysと対称的にこちらはインダストリーからアカデミアへの橋渡し的立ち位置となっています。発表内容は企業での発表者が多く、実際の運用で得られた各企業のMLOpsのベストプラクティスなどがメインで話されています。 個人的にはOpMLのほうが、MLOpsのど真ん中を主体に置いているのでMLSysよりも盛り上がってほしいなと思っています。
OpML&rsquo;19がどのような様子だったかは、以下の記事がわかりやすいです。
OpML ‘19参加レポート The first conference of Operational Machine Learning: OpML ‘19 自分自身、機械学習エンジニアリングやMLOps周りのカンファレンス情報などを追いかけていますが、この分野で査読付きかつ論文として残せる形式の国際会議は主に上記の２つの認識です。
KDDやCOLING、NAACLなどの国際会議でもインダストリートラックが常設されるようになって久しいですが、最近ではインダストリートラックだけではなく、積極的に実応用前提のワークショップ(ECNLP at ACL2020, IRS2020 at KDD2020など)が開催されており機械学習の理論と実応用の融合が進んでいます。
OpML&rsquo;20への投稿と採択で得られたもの OpML&rsquo;20では下記２つの発表枠があり、投稿者がどちらかを選んで発表を行います。
査読付きで20mの口頭発表 2ページの査読付き論文+20mの口頭発表 OpML20で推奨されるトピックでも、自分たちが持っているネタで
New model introduction into production (e.g., staging, A/B test)
においてNoveltyがあると考えて、ここからストーリーを組み立てていきました。
スケジュール感として投稿締切が2020/02/25で、その1ヶ月前の1月末から毎日1時間、Google Calendarで時間を抑えて同僚と集中的に論文の執筆を行いました。 最初にガッと3ページほど書いて、その後洗練させて2ページに圧縮して投稿しました。 あらめて添削や執筆をともに行ってくれた同僚たちに感謝します。
そして投稿の1ヶ月後に通知メールが来て採択を知りました。 添削を何度も繰り返して時間が迫るなかなんとか投稿できたという状態で、とりあえず投稿できて良かったなと感じていた最中だったので、採択通知が来て本当におどきました。&mldr;</div><a href=/posts/2020-09-06/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-08-23/>Python の内包表記とジェネレータ式のメモリ使用量比較</a></h1><time>Aug 23, 2020</time><br><div class=description>リストを構築する際にPythonではリスト内包表記とジェネレータ式の２種類が存在する。 今回、リスト構築時にメモリ使用量にどれだけ差異が発生するのか調査をしてみた。 メモリ使用量の調査には、memory_profilerというパッケージを使用した。
まず、２つのリストのデカルト積のタプルを表示するプログラムでの比較
from memory_profiler import profile @profile def main(): """ Comparision List comprehension VS generator memory usage """ colors = "colors" * 1000 sizes = "S" * 100 for shirts in ((color, size) for color in colors for size in sizes): print(shirts) [print((color, size)) for color in colors for size in sizes] if __name__ == "__main__": main() Filename: src/listcomp_vs_generator.py Line # Mem usage Increment Line Contents ================================================ 4 10.&mldr;</div><a href=/posts/2020-08-23/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-08-04/>AOJの「ITP I」40問をpythonで解いた</a></h1><time>Aug 4, 2020</time><br><div class=description>はじめに コーディングの腕をもっと磨きたいなと思ったので、以下の記事を参考に始めてみた
https://qiita.com/e869120/items/f1c6f98364d1443148b3 全部で 44 問ありますが、最後の 4 問は競プロとはあまり関係ないので、ITP1_1-A から ITP1_10-D までの 40 問を解くことをお勧めします。
まずは最初におすすめされた、AOJのITP1_1-A から ITP1_10-D までの 40 問を解いてみた 無料でこのサービスが提供されてるの素晴らしい 標準入力、出力の整形が少し手間取ったけど、あとは愚直に解いていった
http://judge.u-aizu.ac.jp/onlinejudge/ 感想としては、
やってみたら、意外と楽しい。特に自分で諦めずに試行錯誤して、オンラインで一発でACもらえるとめちゃくちゃ嬉しい テストケースに通る、すなわち正しい、それが書けたら達成感がある 何かしらのお題に沿って、コードを書くという動機ができるので、書くことに慣れたい場合も有用そう togglで時間計測しながら、やって見直してみたら15h46m 費やしていた。大体1問25mくらい
次の目標、
AtCoder で水色を目指す!!! データ構造周りや、アルゴリズム周りはまだまだ弱いのでそこらへんを抑えていきたい 当面は、以下の２つに投資していきます
機械学習だけに縛られない、SWEとしてスキル底上げ 機械学習関係の確固たる基礎知識と実装力 以下に自分が書いた回答例を放流しておきます。
Rule 15分試行錯誤しても、緒がわからない場合は諦める わからなかったとき、もっと上手な書き方は以下を参考にしました https://qiita.com/cmtennis1042/items/5f1e7f071081176e857f ITP1_1_A: Hello World print('Hello world') ITP1_1_B: X Cubic x = input() print(x ** 3) ITP1_1_C: Rectangle a, b = map(int, input().&mldr;</div><a href=/posts/2020-08-04/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-07-25/>How to write the UnitTest with stdin at Pytest</a></h1><time>Jul 25, 2020</time><br><div class=description>If you want to write UnitTest when using stdin in Python. Pytest provide setattr function in monkeypatch
from io import StringIO import sys def divide(): input = sys.stdin.readline return list(input()) def gather(): input = sys.stdin.readline return sum(list(map(int, input().split()))) def test_divide(monkeypatch): monkeypatch.setattr('sys.stdin', StringIO('abc')) assert divide() == ['a', 'b', 'c'] def test_gather(monkeypatch): monkeypatch.setattr('sys.stdin', StringIO('1 2 3')) assert gather() == 6 Reference Monkeypatching/mocking modules and environments I want to use stdin in a pytest test https://gist.&mldr;</div><a href=/posts/2020-07-25/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-06-13/>Machine Learning Casual Talks # 12 を開催しました</a></h1><time>Jun 13, 2020</time><br><div class=description>Machine Learning Casual Talks 第12回を開催しました。 前回から少し開きがあり、7ヶ月ぶりの開催となりました。
https://mlct.connpass.com/event/172550/
今回の個人的なテーマはベストプラクティスとアンチパターンです。
@keigohtr さんには、AWSの各種サービスを使った機械学習実験基盤をアベジャの適用事例と重ね合わせて、説得力のあるベストプラクティスを語っていただきました。 @yuzutas0 さんには、機械学習の前に、データのマネジメントがいかに必要かを語っていただきました。建設的に改善していこうぜという未来が語られていて、個人的にお話を依頼した甲斐がありました 同僚の @overs_5121 さんには、メルカリ : TensorFlow Lite で、気付きにくい便利機能をユーザーに提唱 の裏話や、適用までの泥臭い事例をお話していただきました。 登壇者の皆様、改めて登壇の依頼をご快諾いただきありがとうございました。
また、コロナウイルスの影響もあり試験的ですが完全なオンライン開催となりました。 配信面は今回は完全に @chezou さんに頼らせていただきました。 プロフェッショナルな配信ありがとうございました！ 配信のベストプラクティスや様子などは、こちらを御覧ください
Google MeetとYouTube Liveでオンラインミートアップの配信をした
勉強会の資料と動画 資料ページ Machine Learning Casual Talks #12 - YouTube 所感としては、以前から配信NGの発表以外は積極的にYouTubeで公開していたのだが、参加者の皆様からはオンライン開催でありがたいと声が大きく、個人的に驚きました。
自分が思うに、オンライン参加も配信動画を後から見るのも、リアルタイムで質問ができないこと以外は大きな差異が無いと思っていたのだが、参加者側からすると大きく異なるようで新鮮だった。
オンライン勉強会開催側のコツ 最低でも
配信者 司会者 配信の監視を行う監視者 の3役がいないとオンライン開催は難しいことがわかった
ライブ配信視聴者数は、以下のような遷移となりました。 500人参加申込みがあり、最大視聴者数が252人とギリギリ5割を超えました。
今までのオフラインでの開催は6-8割くらいだったので、それと比較すると上出来かなと思います。 また、オンライン開催はオフライン開催と比べて会場の確保コストや懇親会おじさんの発生などを抑えられるので、その点もありがたかったです。 オフライン開催だと、会場撤収が効率的に終わっても22:00、家に帰ると23:00なので、イベント主催者にとっても開催しやすい気がしますね。
改善点としては、質問の数が少なめだったことと、オフラインでの交流を補うような要素(パネルディスカッションなど）をもう少し入れたいなと思っています。
オンライン開催は、開催コストが高くて継続できないというイベント主催者あるあるの問題を解決する一つのきっかけにもなるんじゃないのかなぁと思いました。
では、また次回のMLCT 開催をお待ち下さい!!&mldr;</div><a href=/posts/2020-06-13/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-05-10/>自走プログラマーを読み終えた</a></h1><time>May 10, 2020</time><br><div class=description>自走プログラマーを読み終えた。
読み始めたきっかけとして、自分は機械学習エンジニアとして現在働いているが、できることの幅を広げるために最近はソフトウェアエンジニアとしてのスキルをもっと伸ばしたいと考えている。
自走プログラマーは、Pythonを使ったアプリケーション開発のアンチパターンとベストプラクティスを例示して学ぶことができる書籍で、今回の自分の状況にすごくフィットしていて楽しく学習することができた。
Python独特のはまりどころは、Kindle: The Hitchhiker’s Guide to Python, The Hitchhiker’s Guide to Python でも数多く参照されていて、こっちも後から読んでおきたいなと思いました。
次は、ちゃんとした Pythonista になれるように、Fluent Python を読みます。@ynqa さん、以前この本を教えて下さり、ありがとうございました。
長らく積ん読になっていますが、毎日読み進めていきます。
20歳頃の寝る間を惜しんで、ウェブアプリを開発していたときのワクワク感が徐々に蘇ってきた気がしています。
ある程度書けるようになってきたら、なにかアプリとか作って公開したいなと思っています！&mldr;</div><a href=/posts/2020-05-10/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-04-27/>ソフトウェア開発における Upstream と Downstream の意味</a></h1><time>Apr 27, 2020</time><br><div class=description>Upstream Upstream はそのシステムが依存しているジョブ Upstream のデザインが変わることで、システムも影響をうける Downstream Downstream はそのシステムが影響を与える影響を与える部分 例えば、Web Application などでは、データベースは Downstream となる
e.g. Web service→ Databese という流れでデータが作成される
Ref https://reflectoring.io/upstream-downstream/ https://softwareengineering.stackexchange.com/questions/71080/what-does-downstream-upstream-design-mean/83686 https://en.wikipedia.org/wiki/Upstream_(software_development) https://en.wikipedia.org/wiki/Downstream_(software_development) &mldr;</div><a href=/posts/2020-04-27/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-04-26/>Pythonの関数のデフォルト引数はmutable(上書きされる)</a></h1><time>Apr 26, 2020</time><br><div class=description>例えば以下のように、デフォルト引数で初期化を行い、文字列を追加する関数があるとする。
def append_to(values=[]): values.append("Hoge") return values 期待する振る舞いとしては。
In [14]: def append_to(values=[]): ...: values.append("Hoge") ...: return values ...: In [17]: append_to() Out[17]: ['Hoge'] In [18]: append_to() Out[18]: ['Hoge'] と関数呼び出しごとに、values は空のリストに初期化されるので上記のように返ってきてほしい
だが、実際に表示されるのは
In [14]: def append_to(values=[]): ...: values.append("Hoge") ...: return values ...: In [17]: append_to() Out[17]: ['Hoge'] In [18]: append_to() Out[18]: ['Hoge', 'Hoge'] である。
実際に内部で何が起きているかというと
In [23]: def append_to(values=[]): ...: values.append("Hoge") ...: return values ...: In [24]: pinfo append_to Signature: append_to(values=[]) Docstring: &lt;no docstring> File: ~/&lt;ipython-input-23-4530a91351ab> Type: function In [25]: append_to() Out[25]: ['Hoge'] In [26]: pinfo append_to Signature: append_to(values=['Hoge']) Docstring: &lt;no docstring> File: ~/&lt;ipython-input-23-4530a91351ab> Type: function In [27]: append_to() Out[27]: ['Hoge', 'Hoge'] In [28]: pinfo append_to Signature: append_to(values=['Hoge', 'Hoge']) Docstring: &lt;no docstring> File: ~/&lt;ipython-input-23-4530a91351ab> Type: function が起きている。 pinfo は ipython上で、オブジェクトの情報が確認できる便利コマンドです。 関数呼び出しごとに、デフォルト引数のvalues が上書きされていっていることがわかります。 これは、Pythonのデフォルト引数が、関数が定義されたときのみ評価され、毎回毎回評価されるわけではない。(Ruby は評価される) ここでわかるのは、mutable&mldr;</div><a href=/posts/2020-04-26/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"><a href=/ class=page-link aria-label=Previous><span aria-hidden=true>← Prev</span></a></span>
<span class="page-item page-next"><a href=/page/3/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><hr><a class=soc href=https://github.com/hurutoriya title=GitHub><i data-feather=github></i></a>|<a class=soc href=https://twitter.com/hurutoriya/ title=Twitter><i data-feather=twitter></i></a>|⚡️
2021 © Shunya Ueta | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer><script>feather.replace()</script></div></body></html>