<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>dataanalysis on hurutoriya</title><link>https://shunyaueta.com/tags/dataanalysis/</link><description>Recent content in dataanalysis on hurutoriya</description><image><url>https://shunyaueta.com/ogp.jpg</url><link>https://shunyaueta.com/ogp.jpg</link></image><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Tue, 10 May 2022 22:00:23 +0900</lastBuildDate><atom:link href="https://shunyaueta.com/tags/dataanalysis/index.xml" rel="self" type="application/rss+xml"/><item><title>社内でデータ分析結果を可視化・共有する際に Google Colab が便利</title><link>https://shunyaueta.com/posts/2022-05-10-2200/</link><pubDate>Tue, 10 May 2022 22:00:23 +0900</pubDate><guid>https://shunyaueta.com/posts/2022-05-10-2200/</guid><description>社内でデータ分析のレポートを書く際は Google Colab がとても便利な事に気がついた。
Google Bigquery でデータを抽出、Google Sheets で可視化 従来だと、自分がやっていた方法として、
Google BQ などで分析対象結果のデータを抽出 その結果を Google Spread Sheet として保存して、Google Sheets の機能で可視化。元の SQL のコードは、別シートを作ってそこに貼り付けておく。 利点としては、一度データを抽出した後は、Google Sheets で二次加工が簡単にできる点がとても便利。 また、 Google Sheet を共有後に Produc Manager が出したい数値を、Product Manager 自身が Google Sheets を元にさっと計算することもできる。
だが、二次加工が便利なのはいいが、大抵の可視化ってパターンが決まっているかつ二次加工の状況が必ず発生するわけではないので、SQL 取得とその可視化を一気通貫でできないかなと考えていた。
なにか良い方法無いかなと思っている矢先に、別のチームの同僚が、Google Colab を使って、BQ を dataframe として保存後 matplotlib で可視化しているのを見かけて、
求めていたのは&amp;hellip;こ、これだ&amp;hellip;.
となり、速攻取り入れました。
良いと思ったところは積極的に真似する
Google Colab なら、データの取得・加工・可視化までを完結可能 Google Colab の利点を列挙しておく
SQL のコード、データ抽出や可視化のロジックなどが Python で記述可能かつ、Google Colab で完結 matplotlib で可視化できるので、見やすく美しい図を作れる そしてそのコードは他のデータ分析でも再利用可能 pandas dataframe で Google BQ からデータを取得するので、Standard SQL だけでは難しい計算も pandas、 numpy や scipy などを使ってデータ加工が簡単にできるのも、便利 Google Sheets 同様、簡単に社内で共有できる Markdown も Google Colab 内で書けるので、凝った文章などもいれてレポートも書ける マジックコマンドで、Google BQ の結果を dataframe として保存1したり、</description></item><item><title>Google が公開している、より良いデータ分析のためのガイドブック「Good Data Analysis」で、データ分析の要所が簡潔にまとめられていて感動した</title><link>https://shunyaueta.com/posts/2022-03-08/</link><pubDate>Tue, 08 Mar 2022 20:42:56 +0900</pubDate><guid>https://shunyaueta.com/posts/2022-03-08/</guid><description>Google の非公式ブログで、The Unofficial Google Data Science Blog というデータサイエンスをテーマにしたブログがある。
その中で、
Practical advice for analysis of large, complex data sets
の記事を元にして作られた Google Developers Guides: Machine Learning Guides &amp;gt; Good Data Analysis を昨日見かけて読んでいたら素晴らしいドキュメントだったので、ここでその感動を共有したかったので筆をとったしだい。
Good Data Analysis の概要 Technical: どのような技術を使ってデータを見るべきか Process: データへの取り組み方。どのような観点でデータを見るべきか Mindset: どのような考えでデータ分析をすすめていくべきか の三段構成でガイドブックが書かれている。
特にガイドブックで自分が好きな言葉は Mindset 章の
Data analysis starts with questions, not data or a technique
データ分析は質問とともにのみ始まる、データや技術からデータ分析は始まらない
と
Be both skeptic and champion
懐疑的であれ、そしてそのデータに一番詳しい存在(チャンピオン)であれ
でした。
最近課題の理解が本当に大事だなと痛感する出来事に直面した後にこのドキュメントを読んだので非常に刺さりました。</description></item><item><title>Standard SQLで 列と列の組み合わせの数を集計したい</title><link>https://shunyaueta.com/posts/2021-02-09/</link><pubDate>Tue, 09 Feb 2021 23:27:37 +0900</pubDate><guid>https://shunyaueta.com/posts/2021-02-09/</guid><description>group by は集計作業において根幹となる処理ですが、少し手の混んだ集計をしたいときに毎回調べていることが多かったのでここに学んだことをまとめておく
今回やりたいことは
A 列が α になっている行の B 列の種類を集計したい
です。
はじめに 実際のデータを用意したほうが、理解が深まるので擬似的なテーブルを作成する。 テーブルのデータの概略として、何日に sender (送信者) が receiver (受信者) にいくら送金(price)したかを格納しているテーブルとする。
StandardSQL は WITH を使って簡単にモックテーブルを作れるのが良いところ。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #standardSQL WITH `transactions` AS ( SELECT &amp;#39;A&amp;#39; AS sender, &amp;#39;B&amp;#39; AS receiver, 600 AS price, &amp;#39;2020-01-01&amp;#39; AS day UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1200, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 600, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;C&amp;#39;, 2000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, 3000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, 2000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 700, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 300, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;D&amp;#39;, 250, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 400, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1000, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1200, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 2000, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 450, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 500, &amp;#39;2020-01-02&amp;#39; ) SELECT * FROM transactions sender receiver price day A B 600 2020-01-01 A B 1200 2020-01-01 A B 1800 2020-01-01 A C 2000 2020-01-01 A D 3000 2020-01-01 A D 2000 2020-01-01 B C 700 2020-01-01 B C 300 2020-01-01 B D 250 2020-01-01 A B 400 2020-01-02 A B 1000 2020-01-02 A B 1200 2020-01-02 A B 2000 2020-01-02 B C 450 2020-01-02 B C 500 2020-01-02 列と列の組み合わせの数を集計する 日次ごとに送金者が何人に送ったかを集計したい、つまり(sender, receiver)のペアを考えて、sender を固定した上で何人に送金したいかを集計したとする。 上記のデータだと</description></item></channel></rss>