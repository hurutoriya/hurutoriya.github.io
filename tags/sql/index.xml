<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>sql on hurutoriya</title><link>https://shunyaueta.com/tags/sql/</link><description>Recent content in sql on hurutoriya</description><image><title>hurutoriya</title><url>https://shunyaueta.com/ogp.jpg</url><link>https://shunyaueta.com/ogp.jpg</link></image><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sat, 06 Nov 2021 22:40:02 +0900</lastBuildDate><atom:link href="https://shunyaueta.com/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>Standard SQLのCOALESCEで、時間経過によってカラム名が変化したデータを柔軟に抽出する</title><link>https://shunyaueta.com/posts/2021-11-06/</link><pubDate>Sat, 06 Nov 2021 22:40:02 +0900</pubDate><guid>https://shunyaueta.com/posts/2021-11-06/</guid><description>データの蓄積帰還が長くなってくると、例えば JSON 形式でログを取っているが、同じデータでもマイグレーションやロギングロジックの更新などでkey の名前が変化したりする場合がある。
その場合取り扱いに困るのが、古い key と新しい key をどのように併合するかだ。 例えば特定の日次できれいにデータが入れ替わっているのなら、色々やりようがあるが、クライアントなどのログの場合データの変化も均一ではないので、徐々に変化していることが大半なので、日次で別々の抽出をして結合するというアプローチも難しい。
その際に役立つのが Standard SQL 条件付き構文の COALESCE だ。
COALECSCE は、引数の最初の非 NULL の値を返す関数で、
1 COALESCE(NULL, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;) だと Bが返される。この関数を使うことで、複数カラムを一つに併合することができる。
具体例を交えつつ実践してみる 例えば、以下のように昔のカラム名が title で、全く同じデータが新しいカラムの title_v2 に入ってきているとする。
NOTE: json を例題に key の抽出にしたほうが実際の状況に沿いますが、カラムのみで表現したほうが説明が簡単なので今回はそちらを採用。
用意したデータ 1 2 3 4 5 6 7 8 WITH menues AS (SELECT &amp;#34;うどん&amp;#34; as title, NULL as title_v2, &amp;#34;2021/10/06&amp;#34; as created UNION ALL SELECT &amp;#34;ラーメン&amp;#34;, NULL, &amp;#34;2021/10/07&amp;#34; UNION ALL SELECT NULL, &amp;#34;そば&amp;#34;, &amp;#34;2021/10/08&amp;#34; UNION ALL SELECT &amp;#34;カツ丼&amp;#34;, NULL, &amp;#34;2021/10/09&amp;#34; UNION ALL SELECT &amp;#34;カツ丼&amp;#34;, &amp;#34;カツ丼&amp;#34;, &amp;#34;2021/10/10&amp;#34; UNION ALL SELECT NULL, &amp;#34;カレー&amp;#34;, &amp;#34;2021/10/11&amp;#34;) SELECT * FROM menues title title_v2 created うどん 2021/10/06 ラーメン 2021/10/07 そば 2021/10/08 カツ丼 2021/10/09 カツ丼 カツ丼 2021/10/10 カレー 2021/10/11 2021/10/10 のデータなどは旧カラムと新カラムにダブルライトされています。</description></item><item><title>Pythonで、変数を挿入して柔軟にSQLクエリを構築する</title><link>https://shunyaueta.com/posts/2021-04-29/</link><pubDate>Thu, 29 Apr 2021 22:52:25 +0900</pubDate><guid>https://shunyaueta.com/posts/2021-04-29/</guid><description>データ処理のタスクをこなしていると、Python で SQL に変数を挿入し柔軟に SQL クエリを構築したくなる。 例えば、
中間テーブルを作るために Airflow などで定期的なジョブを実行し、SQL の createdの時間を当日のものに変更する training, dev, test でデータを分割する際に、createdの条件を変更して 3 パターンのデータを取得する などが考えられる。
変数を SQL に組み込んで実行したい際には、kayak/pypikaのような SQL builder もあるが、個人的に可読性が悪くなったり、SQL クエリの作成のためだけに余計なパッケージをいれたくない。そのためパッケージを入れずにシンプルに完結する方法をここでは紹介する。
編集履歴 2021/05/12: twitter で docstring ではなく string literal ですよという指摘をいただき修正 ref 2021/05/12: twitter での意見を反映 1. 単なる文字列として SQL クエリを構築 1 2 3 def get_guery(num: int, category: str): sql=f&amp;#34;SELECT field1, field2, field3, field4 FROM TABLE WHERE condition1={num} AND condition2={category}&amp;#34; return sql f-string で文字列に変数を挿入して、SQL クエリを構築 だが、
SQL が長くなると PEP8 に準拠せず、E501 line too longに抵触する 視認性が低く、SQL クエリの実行内容を理解しづらい 2.</description></item><item><title>Standard SQLで 列と列の組み合わせの数を集計したい</title><link>https://shunyaueta.com/posts/2021-02-09/</link><pubDate>Tue, 09 Feb 2021 23:27:37 +0900</pubDate><guid>https://shunyaueta.com/posts/2021-02-09/</guid><description>group by は集計作業において根幹となる処理ですが、少し手の混んだ集計をしたいときに毎回調べていることが多かったのでここに学んだことをまとめておく
今回やりたいことは
A 列が α になっている行の B 列の種類を集計したい
です。
はじめに 実際のデータを用意したほうが、理解が深まるので擬似的なテーブルを作成する。 テーブルのデータの概略として、何日に sender (送信者) が receiver (受信者) にいくら送金(price)したかを格納しているテーブルとする。
StandardSQL は WITH を使って簡単にモックテーブルを作れるのが良いところ。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #standardSQL WITH `transactions` AS ( SELECT &amp;#39;A&amp;#39; AS sender, &amp;#39;B&amp;#39; AS receiver, 600 AS price, &amp;#39;2020-01-01&amp;#39; AS day UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1200, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 600, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;C&amp;#39;, 2000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, 3000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, 2000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 700, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 300, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;D&amp;#39;, 250, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 400, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1000, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1200, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 2000, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 450, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 500, &amp;#39;2020-01-02&amp;#39; ) SELECT * FROM transactions sender receiver price day A B 600 2020-01-01 A B 1200 2020-01-01 A B 1800 2020-01-01 A C 2000 2020-01-01 A D 3000 2020-01-01 A D 2000 2020-01-01 B C 700 2020-01-01 B C 300 2020-01-01 B D 250 2020-01-01 A B 400 2020-01-02 A B 1000 2020-01-02 A B 1200 2020-01-02 A B 2000 2020-01-02 B C 450 2020-01-02 B C 500 2020-01-02 列と列の組み合わせの数を集計する 日次ごとに送金者が何人に送ったかを集計したい、つまり(sender, receiver)のペアを考えて、sender を固定した上で何人に送金したいかを集計したとする。 上記のデータだと</description></item></channel></rss>