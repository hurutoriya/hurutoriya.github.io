<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SQL on Shunya Ueta</title><link>https://shunyaueta.com/tags/sql/</link><description>Recent content in SQL on Shunya Ueta</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Thu, 29 Apr 2021 22:52:25 +0900</lastBuildDate><atom:link href="https://shunyaueta.com/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>PythonでSQLに変数を挿入して、柔軟にSQLクエリを構築する</title><link>https://shunyaueta.com/posts/2021-04-29/</link><pubDate>Thu, 29 Apr 2021 22:52:25 +0900</pubDate><guid>https://shunyaueta.com/posts/2021-04-29/</guid><description>データ処理のタスクをこなしていると、PythonでSQLに変数を挿入し柔軟にSQLクエリを構築したくなる。 例えば、
中間テーブルを作るためにAirFlowなどで定期的なジョブを実行し、SQLの createdの時間を当日のものに変更する training, dev, test でデータを分割する際に、createdの条件を変更して3パターンのデータを取得する などが考えられる。
変数をSQLに組み込んで実行したい際には、kayak/pypikaのような SQL builder もあるが、個人的に可読性が悪くなったり、SQLクエリの作成のためだけに余計なパッケージをいれたくない。そのためパッケージを入れずにシンプルに完結する方法をここでは紹介する。
1. 単なる文字列としてSQLクエリを構築 1 2 3 def get_guery(num: int, category: str): sql=f&amp;#34;SELECT field1, field2, field3, field4 FROM TABLE WHERE condition1={num} AND condition2={category}&amp;#34; return sql f-string で文字列に変数を挿入して、SQLクエリを構築 だが、
SQLが長くなるとPEP8に準拠せず、E501 line too longに抵触する 視認性が低く、SQLクエリの実行内容を理解しづらい 2, docstring で複数行文字列として扱いSQLクエリを構築 1 2 3 4 5 6 7 8 def get_guery(num: int, category: str): sql = f&amp;#34;&amp;#34;&amp;#34; SELECT field1, field2, field3, field4 FROM table WHERE condition1={num} AND condition2={category} &amp;#34;&amp;#34;&amp;#34; return sql 1番目と比較すると、docstringを挿入しSQLクエリが複数行になることでで見やすい だが</description></item><item><title>Standard SQLで 列と列の組み合わせの数を集計したい</title><link>https://shunyaueta.com/posts/2021-02-09/</link><pubDate>Tue, 09 Feb 2021 23:27:37 +0900</pubDate><guid>https://shunyaueta.com/posts/2021-02-09/</guid><description>group by は集計作業において根幹となる処理ですが、少し手の混んだ集計をしたいときに毎回調べていることが多かったのでここに学んだことをまとめておく
今回やりたいことは
A列がαになっている行のB列の種類を集計したい
です。
はじめに 実際のデータを用意したほうが、理解が深まるので擬似的なテーブルを作成する。 テーブルのデータの概略として、何日にsender (送信者) が receiver (受信者) にいくら送金(price)したかを格納しているテーブルとする。
StandardSQLはWITHを使って簡単にモックテーブルを作れるのが良いところ。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #standardSQL WITH `transactions` AS ( SELECT &amp;#39;A&amp;#39; AS sender, &amp;#39;B&amp;#39; AS receiver, 600 AS price, &amp;#39;2020-01-01&amp;#39; AS day UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1200, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 600, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;C&amp;#39;, 2000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, 3000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, 2000, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 700, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 300, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;D&amp;#39;, 250, &amp;#39;2020-01-01&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 400, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1000, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 1200, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, 2000, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 450, &amp;#39;2020-01-02&amp;#39; UNION ALL SELECT &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, 500, &amp;#39;2020-01-02&amp;#39; ) SELECT * FROM transactions sender receiver price day A B 600 2020-01-01 A B 1200 2020-01-01 A B 1800 2020-01-01 A C 2000 2020-01-01 A D 3000 2020-01-01 A D 2000 2020-01-01 B C 700 2020-01-01 B C 300 2020-01-01 B D 250 2020-01-01 A B 400 2020-01-02 A B 1000 2020-01-02 A B 1200 2020-01-02 A B 2000 2020-01-02 B C 450 2020-01-02 B C 500 2020-01-02 列と列の組み合わせの数を集計する 日次ごとに送金者が何人に送ったかを集計したい、つまり(sender, receiver)のペアを考えて、sender を固定した上で何人に送金したいかを集計したとする。 上記のデータだと</description></item></channel></rss>